[
  {
    "projectId": "0e3b9d1a-85be-410f-9efe-4fc543436126",
    "testId": "31c4ac67-0f53-48fd-ac97-51dc1e8157c6",
    "userId": "74983418-50c1-7035-f20b-1376d21bb25d",
    "title": "TC001-User Registration with Valid Email and Password",
    "description": "Verify that a new user can successfully register with a valid email address and password.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:8080\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Allow page to load; if no interactive elements appear, navigate directly to the sign-up URL (/signup).\n        await page.goto(\"http://localhost:8080/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try alternate signup route using hash-based routing (#/signup). If that fails, try /register next.\n        await page.goto(\"http://localhost:8080/#/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try an alternate registration route. Navigate to http://localhost:8080/register to see if the sign-up UI loads.\n        await page.goto(\"http://localhost:8080/register\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:8080/auth/signup and wait for the page to load\n        await page.goto(\"http://localhost:8080/auth/signup\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:8080/index.html and wait for the page to load, then scan for interactive elements\n        await page.goto(\"http://localhost:8080/index.html\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Welcome to your dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to register a new user with a valid email and password and expected to be redirected to the dashboard (visible text 'Welcome to your dashboard'), but that text did not appear — registration or redirect likely failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot continue because the application SPA failed to initialize and the sign-up UI is not present. Summary of what was attempted: navigated to these URLs: http://localhost:8080, /signup, #/signup, /register, /auth/signup, /index.html; waited for page loads; inspected page — no interactive elements found (page appears blank). Result: registration flow could not be started and no form fields/buttons were accessible. Recommended next steps for the developer/user: 1) Confirm the dev server is running and serving the SPA assets (check server logs). 2) Open the browser dev console for JS errors (missing bundle, 404s, runtime exceptions). 3) Ensure the build/dev server serves index.html and the JS/CSS files (check network tab for failed requests). 4) If the app uses a different route, provide the correct sign-up URL or enable a visible link to the sign-up page. After these fixes, re-run the test. Because the SPA did not load, this test is incomplete and cannot be verified now.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74983418-50c1-7035-f20b-1376d21bb25d/1770920458706511//tmp/test_task/result.webm",
    "created": "2026-02-12T18:18:22.235Z",
    "modified": "2026-02-12T18:20:58.821Z"
  },
  {
    "projectId": "0e3b9d1a-85be-410f-9efe-4fc543436126",
    "testId": "3cbcabd9-f669-47c2-a358-cb172d800541",
    "userId": "74983418-50c1-7035-f20b-1376d21bb25d",
    "title": "TC002-User Login with Correct Credentials",
    "description": "Validate that a registered user can log in with correct email and password.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:8080\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the sign-in page so the login form becomes available. If the SPA does not initialize, try direct /signin route.\n        await page.goto(\"http://localhost:8080/signin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait 5 seconds for SPA to initialize, then reload the sign-in page (navigate to /signin) to try to get the login form to appear.\n        await page.goto(\"http://localhost:8080/signin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Reload the root page to force SPA initialization, wait 3s, then reload /signin to try to get the login form to appear.\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        await page.goto(\"http://localhost:8080/signin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the sign-in page using an alternate host (http://127.0.0.1:8080/signin) in a new tab and wait for the SPA to initialize.\n        await page.goto(\"http://127.0.0.1:8080/signin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to the hash-based route http://127.0.0.1:8080/#/signin and wait 3 seconds for the SPA to initialize, then check for the login form.\n        await page.goto(\"http://127.0.0.1:8080/#/signin\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test could not be completed: the sign-in page did not initialize and no login form was found. Actions tried: navigated to root and /signin on both localhost and 127.0.0.1 (including hash route), waited multiple times, opened a new tab — the page remained blank and contained no interactive elements. Required test steps (open sign-in page, input credentials, click Login, verify dashboard) cannot continue until the SPA renders the login form.\n\nSuggested next steps to fix the issue before retrying:\n- Verify the dev server is running and serving the SPA (check server logs).\n- Open the browser developer console and network tab to check for JS errors or missing asset 404s.\n- Confirm the correct base path/route configuration for the SPA and that index.html is served for client-side routing.\n- Try restarting the dev server or rebuilding the frontend.\n\nOnce the sign-in form is accessible, re-run the test (will: 1) open sign-in page, 2) input credentials, 3) click Login, 4) verify dashboard). Provide a working URL or confirm the server is fixed to proceed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74983418-50c1-7035-f20b-1376d21bb25d/17709205012218//tmp/test_task/result.webm",
    "created": "2026-02-12T18:18:22.241Z",
    "modified": "2026-02-12T18:21:41.338Z"
  },
  {
    "projectId": "0e3b9d1a-85be-410f-9efe-4fc543436126",
    "testId": "c02c34c9-a8fb-41c9-ac0e-0c0312fd322b",
    "userId": "74983418-50c1-7035-f20b-1376d21bb25d",
    "title": "TC005-Browse Tours by Category",
    "description": "Verify that users can browse tours grouped by categories and that the correct products display under each category.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:8080\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly for the SPA to load; if the page remains blank, navigate directly to the category browsing URL (/categories) to reach the category page.\n        await page.goto(\"http://localhost:8080/categories\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Select the 'Luxury' category from the top navigation to load Luxury category listings (click element index 3003).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/header/div[2]/div[2]/div/nav[4]/div[1]/ul/li/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Luxury' category button (index 3003) again to force loading the Luxury category listings, then wait for the page to update so product cards can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div/header/div[2]/div[2]/div/nav[4]/div[1]/ul/li/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Yacht Experiences' submenu item (index 3823), wait for the page to update, then extract the page heading, 'Showing X experiences' text, and details for each visible product card (title, tags/labels, price, rating) for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div/header/div[2]/div[2]/div/nav[4]/div[2]/div/div/div/div/div[1]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Yacht Experiences').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After selecting the 'Luxury' -> 'Yacht Experiences' category, the page did not display the expected 'Yacht Experiences' heading or the category's tour listings (titles, tags, prices, ratings) did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and findings:\n\nObjective: Verify that users can browse tours grouped by categories and that the correct products display under each category.\n\nWhat was successfully verified:\n- The category browsing page loaded and the default category displayed is: Staycations\n- 'Showing 4 experiences' was observed for Staycations\n- Extracted visible product cards for Staycations (4 items):\n  1) Title: Atlantis The Palm\n     - Badges: Iconic, 5-Star Resort, Palm Jumeirah, Premium Experience\n     - Price text: Starting from AED1,299; AED1,599 19% OFF\n     - Rating: 4.9\n     - Action button text: Explore\n  2) Title: Burj Al Arab\n     - Badges: Luxury, 7-Star Hotel, Jumeirah, Premium Experience\n     - Price text: Starting from AED2,999\n     - Rating: 5\n     - Action button text: Explore\n  3) Title: JW Marriott Marquis\n     - Badges: 5-Star Hotel, Downtown Dubai, Premium Experience\n     - Price text: Starting from AED799; AED999 20% OFF\n     - Rating: 4.7\n     - Action button text: Explore\n  4) Title: Anantara The Palm\n     - Badges: Beach, Beach Resort, Palm Jumeirah, Premium Experience\n     - Price text: Starting from AED999\n     - Rating: 4.8\n     - Action button text: Explore\n\nWhat failed or remains unverified:\n- Switching categories (to verify that selecting another category shows only that category's products) was not successfully completed.\n  - The 'Luxury' category button was clicked twice but the page remained showing 'Staycations'.\n  - Attempt to click a Luxury submenu item (index attempted) failed: element not interactable / possibly stale.\n  - Current browser screenshot shows a blank/white page at the time of final state, suggesting intermittent SPA rendering issues.\n- Because category selection did not complete reliably, verification that the correct products display under other categories (e.g., Luxury) could not be confirmed.\n\nConclusion and recommendation:\n- Partial success: the default category (Staycations) displays the expected 4 products and their details were extracted correctly.\n- Overall goal (verify browsing between categories and correct product lists for each selected category) is not fully verified due to failure to reliably change categories in the UI.\n\nSuggested next steps to complete verification:\n1) Retry category selection using a fresh page load or new tab. Prefer clicking navigation elements rather than direct URL changes.\n2) If elements remain non-interactable, try a full reload and wait longer for SPA to initialize, or inspect console for JS errors (developer assistance required).\n3) If the UI remains unstable, run the test again after fixing frontend render issues so category switching can be validated.\n\nAttached extraction: extracted_content_0.md contains the raw extraction result from the Staycations page.\n\nTest completion status: success=false (partial verification only).\n\nAttachments:\n\nextracted_content_0.md:\n<url>\nhttp://localhost:8080/categories\n</url>\n<query>\nExtract the page heading (main category title), the 'Showing X experiences' summary line, and for each visible product card on the page extract: 1) product title, 2) any badges/tags shown (text of badges like 'LUXURY', '5-STAR RESORT', etc.), 3) price text (e.g., 'Starting from 1,299' or '2,999'), 4) rating (e.g., '4.9'), and 5) any action button text (e.g., 'Explore'). Return results as a list of product objects in the order they appear. Do not follow links. Include only visible cards on the current page.\n</query>\n<result>\n{\n  \"page_heading\": \"Staycations\",\n  \"showing_line\": \"Showing 4 experiences\",\n  \"products\": [\n    {\n      \"title\": \"Atlantis The Palm\",\n      \"badges\": [\n        \"Iconic\",\n        \"5-Star Resort\",\n        \"Palm Jumeirah\",\n        \"Premium Experience\"\n      ],\n      \"price_text\": [\n        \"Starting from AED1,299\",\n        \"AED1,599 19% OFF\"\n      ],\n      \"rating\": \"4.9\",\n      \"action_text\": \"Explore\"\n    },\n    {\n      \"title\": \"Burj Al Arab\",\n      \"badges\": [\n        \"Luxury\",\n        \"7-Star Hotel\",\n        \"Jumeirah\",\n        \"Premium Experience\"\n      ],\n      \"price_text\": [\n        \"Starting from AED2,999\"\n      ],\n      \"rating\": \"5\",\n      \"action_text\": \"Explore\"\n    },\n    {\n      \"title\": \"JW Marriott Marquis\",\n      \"badges\": [\n        \"5-Star Hotel\",\n        \"Downtown Dubai\",\n        \"Premium Experience\"\n      ],\n      \"price_text\": [\n        \"Starting from AED799\",\n        \"AED999 20% OFF\"\n      ],\n      \"rating\": \"4.7\",\n      \"action_text\": \"Explore\"\n    },\n    {\n      \"title\": \"Anantara The Palm\",\n      \"badges\": [\n        \"Beach\",\n        \"Beach Resort\",\n        \"Palm Jumeirah\",\n        \"Premium Experience\"\n      ],\n      \"price_text\": [\n        \"Starting from AED999\"\n      ],\n      \"rating\": \"4.8\",\n      \"action_text\": \"Explore\"\n    }\n  ]\n}\n</result>",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74983418-50c1-7035-f20b-1376d21bb25d/1770920548099986//tmp/test_task/result.webm",
    "created": "2026-02-12T18:18:22.246Z",
    "modified": "2026-02-12T18:22:28.227Z"
  },
  {
    "projectId": "0e3b9d1a-85be-410f-9efe-4fc543436126",
    "testId": "91f0d59a-33f6-455f-9c5c-fa0dd227263a",
    "userId": "74983418-50c1-7035-f20b-1376d21bb25d",
    "title": "TC006-View Detailed Product Page with Dynamic Pricing and Images",
    "description": "Ensure product detail pages correctly display dynamic pricing, image galleries, tours description, and location maps.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:8080\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to load the site (wait for SPA) and if still empty, navigate directly to the tours listing at /tours to find products.\n        await page.goto(\"http://localhost:8080/tours\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to load the SPA using the hash route for tours to trigger client-side routing (navigate to http://localhost:8080/#/tours). If page still empty, try alternative routes or report website issue.\n        await page.goto(\"http://localhost:8080/#/tours\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74983418-50c1-7035-f20b-1376d21bb25d/1770921085885573//tmp/test_task/result.webm",
    "created": "2026-02-12T18:18:22.251Z",
    "modified": "2026-02-12T18:31:26.003Z"
  }
]
